<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Comparisons</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Anonymous+Pro&family=Ubuntu:wght@400;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../../style.css">
  <link rel="stylesheet" href="../style.css">
</head>

<body>

  <header>
    <label class="light">
      <input class="checkbox" type="checkbox">
      <span>Переключатель</span>
    </label>
  </header>

  <main>
    <h1 class="javascript-main__title">Операторы сравнения</h1>

    <h2>Результат сравнения имеет логический тип</h2>

    <p>Все операторы сравнения возвращают значение логического типа.</p>

    <h2>Сравнение строк</h2>

    <p>Чтобы определить, что одна строка больше другой, JavaScript использует «алфавитный» или «лексикографический» порядок.</p>

    <ol>
      <li>Сначала сравниваются первые символы строк.</li>
      <li>Если первый символ первой строки больше (меньше), чем первый символ второй, то первая строка больше (меньше) второй. Сравнение завершено.</li>
      <li>Если первые символы равны, то таким же образом сравниваются уже вторые символы строк.</li>
      <li>Сравнение продолжается, пока не закончится одна из строк.</li>
      <li>Если обе строки заканчиваются одновременно, то они равны. Иначе, большей считается более длинная строка.</li>
    </ol>

    <p><b>Используется кодировка Unicode, а не настоящий алфавит.</b></p>

    <h2>Сравнение разных типов</h2>

    <p>При сравнении значений разных типов JavaScript приводит каждое из них к числу.</p>

    <h2>Строгое сравнение</h2>

    <p>Использование обычного сравнения <b>==</b> может вызывать проблемы. Потому что операнды разных типов преобразуются оператором <b>==</b> к числу.</p>


    <p>Оператор строгого равенства <b>===</b> проверяет равенство без приведения типов. Если <b>a</b> и <b>b</b> имеют разные типы, то проверка <b>a === b</b> немедленно возвращает <b>false</b> без попытки их преобразования.</p>

    <h2>Сравнение с null и undefined</h2>

    <p>При строгом равенстве <b>===</b> эти значения различны, так как различны их типы, но при нестрогом равенстве <b>==</b> эти значения равны друг другу и не равны никаким другим значениям. Это специальное правило языка.</p>

    <h2>Странный результат сравнения null и 0</h2>

    <code class="code-block">
      alert( null > 0 );  // (1) false <br>
      alert( null == 0 ); // (2) false <br>
      alert( null >= 0 ); // (3) true <br>
    </code>

    <p>Причина в том, что нестрогое равенство и сравнения <b>> < >= <=</b> работают по-разному. Сравнения преобразуют <b>null</b> в число, рассматривая его как <b>0</b>. Поэтому выражение (3) <b>null >= 0</b> истинно, а <b>null > 0</b> ложно.</p>

    <h2>Несравненное значение undefined</h2>

    <p>Значение <b>undefined</b> несравнимо с другими значениями:</p>

    <code class="code-block">
      alert( undefined > 0 ); // false (1) <br>
      alert( undefined < 0 ); // false (2) <br>
      alert( undefined == 0 ); // false (3)
    </code>

    <ul>
      <li>Сравнения (1) и (2) возвращают <b>false</b>, потому что <b>undefined</b> преобразуется в <b>NaN</b>, а <b>NaN</b> – это специальное числовое значение, которое возвращает <b>false</b> при любых сравнениях.</li>

      <li>Нестрогое равенство (3) возвращает <b>false</b>, потому что <b>undefined</b> равно только <b>null</b>, <b>undefined</b> и ничему больше.</li>
    </ul>

    <br><br><a class="link-back"  href="../index.html">Назад</a>
  </main>


  <script src="../../script.js"></script>
</body>

</html>