<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>CSS</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Anonymous+Pro&family=Ubuntu:wght@400;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../style.css">
  <link rel="stylesheet" href="style.css">
</head>
<body>
  <header>
    <label class="light">
      <input class="checkbox" type="checkbox">
      <span>Переключатель</span>
    </label>
  </header>

  <main>
    <h1>CSS</h1>

    <p>CSS расшифровывается как «Cascading Style Sheets» - «Каскадная таблица стилей»..</p>

    <p>CSS правило. Правило — это группа свойств и их значений, которая целиком применяется к тем тегам, на которые указывает селектор.</p>

    <code class="code-block">
      селектор {
        свойство: значение;
        свойство: значение;
      }
    </code>

    <h2>Мискование классов</h2>

    <p>У HTML-элемента может быть сколько угодно классов, в этом случае они перечисляются в атрибуте <code>class</code> через пробел.</p>

    <p>Обычно миксование классов используется так: в один класс выносят общее оформление, а в дополнительных классах описываются модификации.</p>

    <h2>Наследование</h2>

    <p>Наследование в CSS — это механизм, с помощью которого значение свойств элемента-родителя передаются его элементам-потомкам. Стили, присвоенные одному элементу, наследуются всеми потомками (вложенными элементами), но только в том случае, если где-то явно не переопределены.</p>

    <h2>Наследуемые свойства</h2>

    <p>К наследуемым относятся в основном свойства, определяющие параметры отображения текста:</p>

    <code class="code-block">
      font-size, font-family, font-style, font-weight, color, text-align, text-transform, text-indent, line-height, letter-spacing, word-spacing, white-space, direction и другие.
    </code>

    <p>Также к наследуемым свойствам относятся <code>list-style, cursor, visibility, border-collapse</code> и некоторые другие. Но они используются значительно реже.
      Наследуемые свойства можно и нужно задавать через предков, следуя структуре документа.</p>

    <h3>Принудительное наследование</h3>

    <p>Для каждого свойства может быть задано значение <code>inherit</code>. Оно означает, что данное свойство принимает такое же значение, как и у родительского.</p>

    <h2>Составные свойства</h2>

    <p>В CSS есть обычные свойства, управляющие одним параметром отображения, и есть составные свойства, управляющие одновременно несколькими параметрами. Например, свойство <code>font</code>. Оно задает сразу шесть параметров: размер и название шрифта, высоту строки и некоторые другие. Если значение обычного свойства не было задано в составном, то браузер при «расшифровке» использует исходное значение этого свойства.</p>

    <code class="code-block">
      font: 16px/26px "Arial", sans-serif; <br><br>

      font-size: 16px;                  /* было задано в font */ <br>
      line-height: 26px;                /* было задано в font */ <br>
      font-family: "Arial", sans-serif; /* было задано в font */ <br>
      font-weight: normal;              /* не было задано в font */ <br>
      font-style: normal;               /* не было задано в font */ <br>
      font-variant: normal;             /* не было задано в font */ <br>
    </code>

    <h2>Типы значений: абсолютные и относительные</h2>

    <p>Абсолютные единицы измерения привязаны к настоящим физическим размерам и связаны между собой жесткими пропорциями. Пиксели, <code>px</code>, используют чаще всего, остальные абсолютные единицы почти не применяют (cm, mm).</p>

    <p>Относительные единицы измерения описывают значения, которые зависят от других значений. Например, ширина элемента в процентах зависит от ширины родительского элемента, а ширина элемента в <code>em</code> зависит от размера шрифта самого элемента. К относительным единицам относятся <code>em</code>, <code>rem</code>, <code>vh</code>, <code>vw</code> и некоторые другие, ну и, конечно же, проценты.</p>

    <h2>Стили по умолчанию</h2>

    <p>Некоторым элементам можно не задавать никаких стилей, но у них всё равно будет какое-то оформление. Например, у списка <code>&lt;ul&gt;</code> есть отступы и маркеры. Такие стили называются стилями по умолчанию и задаются внутри браузерных стилей изначально. Их можно переопределить или сбросить, задав другие значения свойств элементу.</p>

    <h2>Каскадирование</h2>

    <p>Когда браузер отрисовывает страницу, он должен определить итоговый вид каждого HTML-элемента. Для этого он собирает все CSS-правила, которые относятся к каждому элементу, ведь на элемент могут влиять сразу несколько CSS-правил. Механизм комбинирования стилей из разных источников в итоговый набор свойств и значений каждого тега называется каскадностью.</p>

    <h2>Конфликт свойств</h2>

    <p>На один элемент могут действовать несколько CSS-правил. Если в этих правилах есть одинаковые свойства с разными значениями, то возникает конфликт.</p>

    <div>
      <p>Браузеру нужно как-то решать, какими будут итоговые значения конфликтующих свойств. Конфликт разрешается максимум за три шага. Если на текущем шаге определиться не удалось, то выполняется следующий шаг. Вот эти шаги:</p>

      <ol>
        <li>Сравниваются приоритеты стилевых файлов, в которых находятся конфликтующие свойства. Например, авторские (то есть наши) стили приоритетнее браузерных.</li>
        <li>Сравнивается специфичность селекторов у CSS-правил с конфликтующими свойствами. Например, селектор по классу более специфичен, чем селектор по тегу.</li>
        <li>Побеждает то свойство, которое находится ниже в коде.</li>
      </ol>

      <p>Каскад работает и внутри CSS-правил.</p>

    </div>

    <h2>Специфичность</h2>

    <p>В случае, если элемент обладает несколькими классами и селекторы по этим классам задают одно и то же свойство с разными значениями, более высоким приоритетом обладает то правило, которое расположено в CSS-коде <i>ниже</i>.</p>

    <p>Чем меньшее количество элементов потенциально может выбрать селектор, тем он специфичнее.</p>

    <p>Селектор <code>.red</code> выберет все теги с нужным классом, а селектор <code>p.red</code> выберет только абзацы с нужным классом. Поэтому селектор <code>p.red</code> является более спицефичным, чем селектор <code>.red</code>.</p>

    <p>Селектор по <code>id</code> может выбрать только один элемент. И поэтому он на порядок специфичнее селекторов по тегам, классам, а также комбинаций этих селекторов.</p>

    <p>CSS-правила, которые прописаны в <code>style</code> обладают наивысшим приоритетом. Такой способ задания стилей не приветствуется в профессиональной вёрстке сайтов и годится только для создания быстрых прототипов.</p>

    <p>Существует способ переопределить из подключаемых CSS-файлов даже стили, заданные в атрибуте <code>style</code>. Для этого нужно использовать ключевое слово <code>!important</code>. Оно задаёт CSS-свойству усиленный приоритет. При вёрстке не рекомендуется часто использовать <code>!important</code>.</p>

    <h3>РАСЧЕТ ЗНАЧЕНИЯ СПЕЦИФИЧНОСТИ</h3>

    <div>
      <p>Специфичность селектора разбивается на 4 группы — <code>a</code>, <code>b</code>, <code>c</code>, <code>d</code>:</p>

      <ul>
        <li>если стиль встроенный, то есть определён как style="...", то а=1, иначе a=0;</li>
        <li>значение <code>b</code> равно количеству идентификаторов (тех, которые начинаются с <code>#</code>) в селекторе;</li>
        <li>значение <code>c</code> равно количеству классов, псевдоклассов и селекторов атрибутов;</li>
        <li>значение <code>d</code> равно количеству селекторов по тегу и псевдо-элементов.</li>
      </ul>
    </div>

    <h2>Свойство font-family</h2>

    <p>Устанавливает шрифт. В начале списка располагают самый желаемый шрифт, затем менее желаемый, а в самом конце списка — общий тип шрифта. Браузер проходит по списку слева направо и использует первый найденный в системе или на сайте шрифт. Если название шрифта состоит из нескольких слов, то его нужно заключать в кавычки. Одинарные названия можно оставлять как без кавычек, так и с ними для единообразия. Если браузер не находит на сайте или в операционной системе ни одно из перечисленных названий шрифтов, то он применяет последнее значение — общий системный тип шрифта.</p>

    <p>Самые распространенные типы шрифта:</p>

    <ul>
      <li><code>serif</code> — шрифт с засечками;</li>
      <li><code>sans-serif</code> — шрифт без засечек;</li>
      <li><code>monospace</code> — моноширенный шрифт;</li>
      <li><code>cursive</code> — шрифт с неформальным начертанием, например, имитация рукописного текста или леттеринга;</li>
      <li><code>fantasy</code> — декоративный шрифт, например, всемирно известный Comic Sans.</li>
    </ul>

    <h2>Свойство font-size</h2>

    <p>Управляет размером шрифта. Значение свойства задает желаемую высоту символа шрифта. Можно задавать абсолютные и относительные значения. Чтобы при изменении основного шрифта родителя его дочерние элементы пропорционально меняли свои размеры шрифта, есть специальная единица измерения — <code>em</code>. Величина <code>1em</code> — такой же размер шрифта, что и у родителя. Соответственно, если нужно, чтобы шрифт дочернего элемента был всегда в 2 раза больше родительского, то надо задать значение <code>2em</code></p>

    <h2>Свойство line-height (интерлиньяж)</h2>

    <p>Свойство управляет высотой строки или межстрочным интервалом. По умолчанию свойство имеет значение <code>normal</code>. Оно указывает браузеру, что межстрочный интервал нужно подобрать автомачтически, исходя из размера шрифта. Спецификация рекомендует устанавливать его в пределах <code>100-120%</code> от размера шрифта.</p>

    <p>Значение <code>normal</code> позволяет всем нестилизованным текстам выглядеть удобочитаемо. Однако, если есть необходимость отойти от стилизации по умолчанию, можно задать фиксированное абсолютное значение в <code>px</code>. Если нужно задать относительное значение, но не такое как <code>normal</code>, то значение задается в процентах или в виде множителя. В таком случае браузер вычисляет значение динамически в зависимости от <code>font-size</code>:</p>

    <code class="code-block">
      p { <br>
&nbsp;&nbsp;font-size: 10px; <br>
&nbsp;&nbsp;line-height: 150%; /* вычисленное значение: 10px * 150% = 15px */ <br>
&nbsp;&nbsp;line-height: 2; /* вычисленное значение: 10px * 2 = 20px; */ <br>
      }
    </code>

    <h2>Свойство text-align</h2>

    <p>Описывает, как вырванивается текст и другие <code>инлайновые</code> элементы (изображения, инлайн-блоки, инлайн-таблицы и др.) внутри блока по горизонтали. Важно помнить, что свойство применяется именно к самому блоку-контейнеру, внутри которого находится текстовый контент</p>

    <h2>Свойство vertical-align</h2>

    <p>Свойством можно выравнивать инлайновые элементы относительно содержащей его строки. Самый простой пример — выровнять картинку по вертикали в текстовой строке. В отличие от <code>text-align</code> свойство <code>vertical-align</code> задается самому элементу, а не содержащему его контейнеру.</p>

    <h2>Свойство color</h2>

    <p>Цвет может быть задан в виде ключевого слова (приводится в <a href="https://www.w3.org/TR/css-color-3/#svg-color" target="_blank" rel="nofollow noopener">спецификации</a>).</p>

    <p>Или в виде шестнадцетеричного значения (#0000000, #fff). В этом случае цвет формируется из красной, зелёной и синей составляющих, заданных в виде шестнадцатеричного числа от 00 до ff. Помимо шести, цветовой код может содержать три знака, в этом случае второй символ в цветовых составляющих дублируется первым. (#a23 == #aa2233)</p>

    <p>Если не хочется иметь дело с шестнадцатеричными значениями, можно воспользоваться специальной функцией <code>rgb</code>, в которой указывается цвет в более привычном десятичном виде в диапозоне от 0 до 255 также в виде трех цветовых составляющих, перечисленных через запятую.</p>

    <p>У функции <code>rgb</code> есть расширенная версия — <code>rgba</code>. В этом случае помимо указания цвета последним значением указывается степень непрозрачности цвета — alpha. Значение может быть от 0 (полностью прозрачный) до 1 (полностью непрозрачный).</p>

    <h2>Свойство white-space, управление пробелами</h2>

    <div>
      <p>Браузер игнорирует множественные пробелы и переносы строк в HTML-коде. С помощью этого свойства можно управлять пробелами и переносами строк.</p>

      <ul>
       <li><code>nowrap</code> — схлопывает лишние пробелы и отображает весь текст одной строкой без переносов;</li>
       <li><code>pre</code> — сохраняет пробелы и переносы как в исходном коде аналогично тегу <code>&lt;pre&gt;</code>;</li>
       <li><code>pre-wrap</code> — работает как значение <code>pre</code>, но добавляет автоматические переносы, если текст не помещается в контейнер;</li>
       <li><code>normal</code> — режим по умолчанию: лишние пробелы и переносы строк слопываются, текст переносится, пробелы в конце строк удаляются.</li>
      </ul>
    </div>

    <h2>Свойство text-decoration</h2>

    <div>
      <p>Задает дополнительное оформление текста.</p>

      <ol>
        <li><code>underline</code> — подчеркивание;</li>
        <li><code>line-through</code> — зачеркивание;</li>
        <li><code>overline</code> — надчеркивание;</li>
        <li><code>none</code> — убиравет вышеперчисленные эффекты.</li>
      </ol>

      <p>К тексту можно одновременно применить несколько эффектов, если перечислить значение через пробел. Это свойство - составное. Оно раскладывается на отдельные свойства.</p>

      <ul>
        <li><code>text-decoration-line</code> — вид линии: зачеркивание, подчеркивание или надчеркивание;</li>
        <li><code>text-decoration-style</code> — стиль линии, может принимать значения:
          <ul>
            <li><code>solid</code> — сплошная линия;</li>
            <li><code>double</code> — двойная линия;</li>
            <li><code>dotted</code> — точечная линия;</li>
            <li><code>dashed</code> — пунктирная линия;</li>
            <li><code>wavy</code> — волнистая линия;</li>
          </ul>
        </li>
        <li><code>text-decoration-color</code> — цвет линии.</li>
      </ul>
    </div>

    <h2>Свойство font-weight</h2>

    <p>Параметр шрифта, которым мы можем управлять насыщенностью или толщиной шрифта. В качестве значения можно использовать ключевое слово или число.</p>

    <ul>
      <li>100: Thin;</li>
      <li>200: Extra Light (Ultra Light);</li>
      <li>300: Light;</li>
      <li>400: Normal;</li>
      <li>500: Medium;</li>
      <li>600: Semi Bold (Demi Bold);</li>
      <li>700: Bold;</li>
      <li>800: Extra Bold (Ultra Bold);</li>
      <li>900: Black (Heavy).</li>
    </ul>

    <h2>Свойство font-style</h2>

    <div>
      <p>Свойством можно задать начертание текста:</p>

      <ul>
        <li><code>noraml</code> — обычное начертание;</li>
        <li><code>italic</code> — курсивное начертание;</li>
        <li><code>oblique</code> — наклонное начертание;</li>
      </ul>

      <p>Если задано значение <code>italic</code>, браузер будет пытаться найти в заданном шрифте отдельное курсивное начертание символов. В некоторых шрифтах отдельный курсив предусмотрен. Если отдельного курсивного начертания в шрифте не предусмотрено, то браузер сделает текст наклонным, то есть сымитирует курсив. Что равноценно тексту значения <code>font-style: oblique</code>.</p>
    </div>

    <h2>Свойство text-transform</h2>

    <p>С его помощью можно управлять регистром символов:</p>

    <ul>
      <li><code>lowercase</code> — все строчные;</li>
      <li><code>uppercase</code> — все заглавные;</li>
      <li><code>capitalize</code> — каждое слово начинается с большой буквы;</li>
      <li><code>none</code> — отменяет изменения регистра.</li>
    </ul>

    <h2>Свойство background</h2>

    <p>Задать фон можно с помощью сокращенного свойства <code>background</code>, в котором через пробел перечисляются его компоненты:</p>

    <code class="code-block">
      background: [color, image, repeat, position, attachment];
    </code>

    <h2>Селекторы</h2>

    <h3>СЕЛЕКТОРЫ ПО ТЕГАМ</h3>

    <code class="code-block">
      li {
        <br><br>
      }
    </code>

    <h3>СЕЛЕКТОРЫ ПО КЛАССАМ</h3>

    <code class="code-block">
      .first {
        <br><br>
      }
    </code>

    <p>Имена классов могут состоять из латинских символов, цифр и знаков <code>-</code> и <code>_</code>. Имя класса должно начинаться с латинской буквы. Синтаксис CSS позволяет выбирать элементы одновременно по тегу и по классу или же элемент с двумя классами сразу. Для этого селектор составляется просто одной строкой из всех желаемых «частей» без пробелов.</p>

    <h3>КОНТЕКСТНЫЕ СЕЛЕКТОРЫ</h3>

    <code class="code-block">
      /* выбрать все теги strong внутри тегов p */ <br>
      p strong { ... } <br><br>

      /* выбрать все элементы с классом .hit внутри тегов ul */ <br>
      ul .hit { ... } <br><br>

      /* выбрать все ссылки внутри элементов с классом .menu,
        которые лежат внутри элементов с классом .footer */ <br>
      .footer .menu a { ... }
    </code>

    <p>Селектор может состоять из нескольких частей, разделённых пробелом. Такие селекторы называют <i>конекстными</i> или <i>вложенными</i>. Читать их проще всего справа налево.</p>

    <h3>СОСЕДНИЕ СЕЛЕКТОРЫ</h3>

    <p>Соседние селекторы используются для расположенных рядом элементов. Соседние селекторы записываются с помощью знака <code>+</code>, например, <code>селектор1 + селектор2</code>.</p>

    <h3>ДОЧЕРНИЕ СЕЛЕКТОРЫ</h3>

    <p>Любые элементы, расположенные внутри родительского элемента называются потомками. А дочерними элементами являются ближайшие потомки. Если нужно задать стили только для дочерних элементов используется дочерний селектор, в котором используется символ <code>></code>. Например: <code>ul > li</code> или <code>ul > li > span.</code></p>

    <h3>СЕЛЕКТОР ПОСЛЕДУЮЩИХ ЭЛЕМЕНТОВ</h3>

    <p>Селектор <code>селектор1 ~ селектор2</code> применяет стили к элементу, подходящему под <code>селектор2</code>, только если перед ним расположен элемент, подходящий под <code>селектор1</code>. Оба элемента должны принадлежать одному родителю.</p>

    <h3>СЕЛЕКТОРЫ АТРИБУТОВ</h3>

    <p>Селекторы атрибутов позволяют выбирать элементы по любым атрибутам. Они записываются с использованием квадратных скобок: <code>элемент[атрибут]</code>.</p>

    <h3>СЕЛЕКТОР ПО ID</h3>

    <p>Для атрибута id существует специальный селектор. Он записывается с помощью символа <code>#</code></p>

    <h3>ПСЕВДОКЛАССЫ</h3>

    <p>Псевдоклассы — это дополнения к обычным селекторам, которые делают их ещё точнее и мощнее. Псевдокласс добавляется к селектору c помощью символа <code>:</code>.</p>

    <code class="code-block">
      a:visited { ... } <br>
      li:last-child { ... } <br>
      .alert:hover { ... } <br>
    </code>

    <p>Псевдокласс <code>first-child</code> позволяет выбрать первый дочерний элемент родителя, а <code>last-child</code> — последний дочерний элемент.</p>

    <p>С помощью псевдокласса <code>nth-child</code> можно выбирать теги по порядковому номеру. Синтаксис псевдокласса: <code>селектор:nth-child(выражение)</code>. Выражением может быть число или формула. </p>

    <h3>ПСЕВДОКЛАССЫ :nth-last-child</h3>

    <p>Псевдокласс используется для добавления стиля к элементам на основе нумерации в дереве элементов. В отличие от <code>:nth-child</code> отсчет ведется не от первого а от последнего элемента.</p>

    <h3>ПСЕВДОКЛАССЫ :first-of-type и :last-of-type</h3>

    <p>Псевдокласс <code>:first-of-type</code> выбирает первый дочерний элемент родителя с учетом тега элементов.</p>

    <p>Псевдокласс <code>:last-of-type</code> выбирает последний дочерний элемент родителя с учетом тега.</p>

    <h3>ПСЕВДОКЛАССЫ :nth-of-type и :nth-last-of-type</h3>

    <p>Псевдокласс <code>:nth-of-type</code> работает почти так же, как и :nth-child. Разница заключается в том, что он учитывает тег элемента. При помощи данного псевдокласса можно выбрать определённый по счёту дочерний элемент определённого типа.</p>

    <p>Псевдокласс <code>:nth-last-of-type</code> также выбирает элементы по их расположению, учитывая их тег, но отсчет ведется от конца.</p>

    <h3>ПСЕВДОКЛАССЫ СОСТОЯНИЙ</h3>

    <p>Благодаря некоторым селекторам можно добавлять в интерфейс динамику и интерактивность. <br>
      Псевдокласс <code>:hover</code> позволяет выбрать элемент, когда на него наведён курсор мыши и кнопка мыши не нажата.</p>

    <div>
      <code class="code-block">
        a:hover {...}
      </code>

      <p>Существуют специальные псевдоклассы для ссылок:</p>

      <ul>
        <li><code>:link</code> выбирает еще не посещенные ссылки;</li>
        <li><code>:visited</code> выбирает посещенные ссылки;</li>
        <li><code>:active</code> выбирает активные ссылки (кнопка мыши зажата на ссылке).</li>
      </ul>
    </div>

    <p>Псевдокласс <code>:focus</code> позволяет выбрать элемент, который в данный момент в фокусе.</p>

    <h3>ПСЕВДОКЛАСС :not</h3>

    <p>Псевдокласс <code>:not(селектор)</code> является отрицающим селектором. С его помощью можно выбирать элементы, которые <i>НЕ</i> содержать указанный селектор. В качестве селектора могут указываться псевдоклассы, теги, идентификаторы, классы и селекторы атрибутов. Нельзя использовать двойной вложенный псевдокласс<code>:note</code>.</p>

    <div>
      <p>Также в комбинации с <code>:not</code> не применяются:</p>
      <ul>
        <li>объединение селекторов: <code>li:not(.heart.jack)</code></li>
        <li>псевдоэлементы <code>li:not(::after)</code></li>
        <li>селекторы-потомки, групповые селекторы или комбинации: <code>li:not(a span)</code> или <code>li:not(a+span)</code></li>
      </ul>
    </div>

    <h3>ПСЕВДОКЛАСС :empty</h3>

    <p>Псевдокласс <code>:empty</code>, выбирает только те теги, у которых нет дочерних элементов (в том числе текстовых узлов).</p>

    <h3>ПСЕВДОКЛАСС :only-child</h3>

    <p>Псевдокласс <code>:only-child</code> используется, когда нужно прописать индивидуальные стили для элемента, который является единственным дочерним элементом внутри родительского контейнера.</p>

    <h3>ПСЕВДОКЛАСС :only-of-type</h3>

    <p>Псевдокласс <code>:only-of-type</code> используется, когда нужно прописать индивидуальные стили для элемента, который является единственным дочерним элементом указанного типа внутри родительского контейнера.</p>

    <h3>ПСЕВДОЭЛЕМЕНТЫ</h3>

    <h3>ПСЕВДОЭЛЕМЕНТЫ ::before и ::after</h3>

    <p>Псевдоэлемент <code>before</code> позволяет с помощью CSS добавить псевдотег внутрь другого элемента и оформить его. Содержимое псевдотега задаётся с помощью свойства <code>content</code>. Чтобы псевдоэлемент появился, ему необходимо задать свойство <code>content</code>. Достаточно даже пустой строки в значении свойства — <code>content: "";</code>.</p>

    <p>Псевдоэлемент аналогичен . Отличие заключается в том, что он добавляет псевдотег не в начало, а в конец элемента. Псевдоэлементы <code>before</code> и <code>after</code> можно использовать одновременно.</p>

    <h3>ПСЕВДОЭЛЕМЕНТЫ ::first-line и ::first-letter</h3>

    <p>Псевдоэлемент <code>first-line</code> задает стиль первой строки форматированного текста. В правилах стиля допустимо использовать только свойства, относящиеся к шрифту, изменению цвета текста и фона.</p>

    <p>Аналогично псевдоэлемент <code>first-letter</code> определяет стиль первого символа в тексте элемента, к которому добавляется. К этому псевдоэлементу могут применяться только стилевые свойства, связанные со свойствами шрифта, полями, отступами, границами, цветом и фоном.</p>

    <h2>FLOAT:</h2>

    <p>Существует несколько способов управлять потоком и строить сетки:</p>

    <ol>
      <li>float;</li>
      <li>inline-block;</li>
      <li>table</li>
      <li>flex</li>
    </ol>

    <p>Изначально <code>float</code> было предназначено для того, чтобы включать обтекание элементов текстом. Наподобие того, как в более старой версии HTML текст обтекал изображения c атрибутами <code>align="left"</code> или <code>align="right"</code>.</p>

    <p><code>float</code> — это свойство, включающее режим обтекания. Но, как часто бывает, судьба уготовила ему совсем другую роль.</p>

    <p>Свойство <code>float</code> имеет следующие значения:</p>

    <ul>
      <li><code>left</code> — прижимает элемент к левому краю родителя, другие элементы обтекают его справа;</li>
      <li><code>right</code> — прижимает элемент к правому краю родителя, другие элементы обтекают его слева;</li>
      <li><code>none</code> — отключает режим обтекания и возвращает элементу нормальное поведение.</li>
    </ul>

    <h3>FLOAT И ШИРИНА</h3>

    <p>Блочные элементы растягиваются на всю доступную ширину родителя. </p>

    <p>Если мы задаём элементу свойство <code>float:left</code> или <code>float:right</code>, то он прижимается к левому или правому краю, а также начинает ужиматься по ширине под своё содержимое. С той стороны, которая не прижата к краю родителя, появляется свободное место. Это место может быть занято другими элементами. </p>

    <p>Зафлоаченному элементу можно явно задавать размеры и отступы.</p>

    <p>Есть тонкость, связанная со строчными элементами. Если зафлоатить строчный элемент, то он начинает вести себя как блочный, а именно: воспринимать размеры и отступы.</p>

    <h3>FLOAT И ВЫПАДАНИЕ ИЗ ПОТОКА</h3>

    <p>Зафлоаченные элементы выпадают из потока, но лишь частично:</p>

    <ul>
      <li><i>Блочные</i> элементы, которые идут в коде после зафлоаченного блока, перестают его замечать. Они подтягиваются вверх и занимают его место, как будто его и нет.</li>
      <li><i>Строчные</i> же элементы, расположенные в коде после зафлоаченного блока, начинают обтекать его со свободной стороны.</li>
    </ul>

    <p>Такое поведение флоатов даёт интересные эффекты:</p>

    <ol>
      <li>Эффект <i>прохождения сквозь блоки</i>. Проявляется, когда зафлоаченный элемент выше, чем несколько последующих за ним блоков.</li>
      <li>Эффект <i>выпадания из родителя</i> или <i>схлопывания родителя</i>. Проявляется тогда, когда все дочерние блоки в родителе зафлоачены. В этом случае родитель схлопывается по высоте, как будто в нём нет содержимого, а блоки выпадают из него.</li>
    </ol>

    <h3>СВОЙСТВО CLEAR</h3>

    <p>Свойство <code>clear</code> запрещает обтекание элемента другими элементами. Вот его значения:</p>

    <ol>
      <li><code>left</code> — запрещено обтекание слева;</li>
      <li><code>right</code> — запрещено обтекание справа;</li>
      <li><code>both</code> — запрещено обтекание с обеих сторон;</li>
      <li><code>none</code> — обтекание разрешено.</li>
    </ol>

    <h3>БОРЬБА С ВЫПАДАНИЕМ ФЛОАТОВ: ПСЕВДОРАСПОРКИ</h3>

    <code class="code-block">
      .clearfix::after {<br>
        &nbsp;&nbsp;content: ""; <br>
        &nbsp;&nbsp;display: table; <br>
        &nbsp;&nbsp;clear: both; <br>
      }
    </code>

    <p><code>clearfix</code> добавляется к контейнеру, внутри которого лежат флоатные колонки.</p>

    <h2>INLINE-BLOCK</h2>

    <p>Блочно-строчные элементы ведут себя двояко. Снаружи они выглядят как обычные строчные, но внутри они ведут себя как блочные. <br> От строчных им достались следующие черты:</p>

    <ul>
      <li>по ширине они ужимаются под своё содержимое;</li>
      <li>могут располагаться в одну строку;</li>
      <li>реагируют на вертикальное выравнивание, vertical-align;</li>
      <li>реагируют на горизонтальное выравнивание, <code>text-align</code>, заданное у родителя.</li>
    </ul>

    <p>От блочных:</p>

    <ul>
      <li>им можно задавать размеры с помощью <code>width</code> и <code>height</code>;</li>
      <li>а также внешние и внутренние отступы и рамки, которые работают во всех направлениях и увеличивают размер элемента.</li>
    </ul>

    <h3>INLINE-BLOCK И ПРОБЕЛЫ В КОДЕ</h3>

    <p>Причина заключается в пробелах после тегов в HTML-коде. Блочно-строчные ведут себя как текст, поэтому если в коде есть пробел между элементами, то он отображается и на странице. Этот пробел увеличивает отступы между товарами, не давая им поместиться в одну строку.</p>

    <p>Бороться с пробелом после блочно-строчных можно несколькими способами:</p>

    <ul>
      <li>удалять пробелы в коде;</li>
      <li>обнулять размер шрифта;</li>
      <li>играться с маргинами после блочно-строчного.</li>
    </ul>

    <h2>Декоративные элементы</h2>

    <h3>text-indent</h3>

    <code class="code-block">
      text-indent: 3px;
    </code>

    <p><code>text-indent</code> определяет размер отступа (пустого места) перед строкой в текстовом блоке. По умолчанию оно управляет отступом только первой строки блока, однако ключевые слова <code>hanging</code> и <code>each-line</code> могут изменять данное поведение.</p>

    <h2>Box-shadow</h2>

    <code class="code-block">
      box-shadow: <br>
      [inset] — внутренняя <br>
      5px     <— смещение по x <br>
      10px    — смещение по y <br>
      [2px]   — размытие <br>
      [3px]   — растяжение <br>
      [red];  — цвет <br>
    </code>

    <p>Растяжение, размытие и цвет могут быть не обязательными. Порядок следование цифровых значений важен.</p>

    <h3>Размытие тени</h3>

    <p>Чем меньше значение, тем четче тень. Максимальная четкость достигается при нулевом значении. Размытие не может быть отрицательным. Если размытие не указано, то оно равно нулю.</p>

    <h3>Растяжение тени</h3>

    <p>При нулевом (или не указанном) растяжении размер тени такой же, как у элемента. При положительном растяжении размер тени становится больше размера элемента, а при отрицательном — меньше.</p>

    <h3>Размытие + растяжение</h3>

    <p>Внешний вид тени будет зависеть от соотношения величин размытия и растяжения:</p>

    <ol>
      <li>размытие есть, растяжение отрицательное — тень очень светлая;</li>
      <li>размытие есть, растяжения нет — тень обычная;</li>
      <li>размытие больше растяжения — тень темнее обычного;</li>
      <li>размытие меньше растяжения — тень очень темная.</li>
    </ol>

    <h3>Цвет тени</h3>

    <p>Цвет тени задается с помощью любого цветового формата CSS. Если цвет тени не задан, то он берётся от цвета текста элемента с тенью.</p>

    <h3>Полупрозрачная тень</h3>

    <p>Если у тени ненулевой радиус размытия, то она автоматически становится полупрозрачной. Но иногда нужно сделать полупрозрачной тень без радиуса размытия. Для этого можно использовать новый формат записи цветов в CSS — <code>rgba</code>.</p>

    <h3>Множественные тени</h3>

    <p>Свойство <code>box-shadow</code> позволяет задавать одному элементу несколько теней. Для этого нужно перечислить значения теней через запятую. Тени, которые расположены в списке выше, будут перекрывать тени, которые расположены ниже.</p>

    <h2>Декаративные эффекты</h2>

    <h3>Content attr</h3>

    <p>Мы можем обращаться к текстовому значению атрибута HTML-элемента непосредственно из CSS. Делается это с помощью свойства <code>content</code>, задающего генерируемое содержимое псевдоэлементов и функции <code>attr()</code>, которая применяется для добавления значения атрибута HTML-элемента в стилевое свойство.</p>

    <code class="code-block">
      p::before { <br>
        &nbsp;&nbsp;content: attr(data-text) " "; <br>
        &nbsp;&nbsp;// С помощью пустой строки в конце добавится пробел <br>
      }
    </code>

    <h3>Линейные градиенты</h3>

    <p>Градиенты описываются внутри CSS-свойства <code>background-image</code>. <br>Сам градиент создаётся функцией <code>linear-gradient</code>, в параметрах которой указываются направление градиента и набор цветов. Направление можно не указывать, тогда будет использовано значение по умолчанию — сверху вниз. Цветов может быть любое количество.</p>

    <h3>Направление градиента</h3>

    <p>Направления градиента задаются с помощью ключевых слов: <code>top</code>, <code>bottom</code>, <code>left</code>, <code>right</code>. <br> Направление градиента располагается перед списком цветов и включает в себя частицу <code>to</code>. Она была добавлена в синтаксис для улучшения читабельности и наглядности:</p>

    <code class="code-block">
      background-image: linear-gradient(to right, yellow, green);
    </code>

    <h3>Градиенты по диагоналям</h3>

    <p>Градиенты можно направлять по диагонали, из угла в угол. Для этого нужно комбинировать <code>top</code>, <code>bottom</code> и <code>left</code>, <code>right</code>. Например, градиент, идущий из левого нижнего в правый верхний угол:</p>

    <code class="code-block">background-image: linear-gradient(to right top, yellow, green);</code>

    <h3>Градиенты под углом</h3>

    <p>Направление линейного градиента можно задавать и в виде произвольного угла, например, <code>245°</code>. Направление в градусах задаётся с помощью единицы измерения <code>deg</code>. Можно задавать положительные и отрицательные углы. Примеры:</p>

    <code class="code-block">
      background-image: linear-gradient(90deg, yellow, green); <br>
      background-image: linear-gradient(-135deg, yellow, green);
    </code>

    <p><code>0deg</code> соответствует 12 часам, а отсчёт угла идет по часовой стрелке. В случае, если угол задан отрицательным значением, например,<code> -90deg</code>, то он отсчитывается против часовой стрелки.</p>

    <h3>Диагонали против градусов</h3>

    <p>Иногда градиенты с направлениями, заданными с помощью градусов и диагоналей, выглядят одинаково. Однако их поведение отличается. Градиенты, заданные с помощью градусов, не зависят от формы контейнера, а диагональные градиенты зависят. Диагональные градиенты всегда остаются привязанными к своим углам.</p>

    <h3>Равномерный многоцветный градиент</h3>

    <p>В линейный градиент можно включать больше двух цветов. Для этого цвета просто перечисляются через запятую.</p>

    <code class="code-block">linear-gradient(to right, red, yellow, green)</code>

    <h3>Пропорции цветов и колорстопы</h3>

    <p>По умолчанию цвета в градиентах распределяются равномерно, в одинаковых пропорциях, но этим поведением можно управлять. Делается это с помощью так называемых колорстопов, которые записываются сразу после значений цветов, например, <code> red 0%, yellow 100%</code>. Колорстоп указывает положение цвета в градиенте, его можно задавать в процентах, пикселях и других единицах.</p>

    <h3>Резкие переходы цветов</h3>

    <p>Позиция цвета (или колорстоп) задаёт расположение центральной части цвета, ту точку, от которой начинается переход в другой цвет. А что будет, если задать для соседних цветов одну и ту же позицию? В этом случае получится резкий переход цветов, так как они оба будут «вытекать» из одной точки в противоположных направлениях.</p>

    <h3>Цветовые переходы в px</h3>

    <p>Цветовые переходы градиента можно также задавать в пикселях. Работают они по аналогии с процентными переходами. Отличие заключается в том, что процентные переходы зависят от размера элемента, а переходы в пикселях — нет.</p>

    <h3>Полупрозрачные градиенты</h3>

    <p>В CSS вы можете задать любой цвет с полупрозрачностью или даже задать прозрачный цвет. Это делается с помощью <code>rgba</code>-значений цветов, в которых помимо трёх цветовых компонент присутствует прозрачность. Примеры:</p>

    <ul>
      <li><code>rgba(255, 255, 255, 1)</code> — обычный белый цвет</li>
      <li><code>rgba(255, 255, 255, 0.5)</code> — наполовину прозрачный белый.</li>
      <li><code>rgba(255, 255, 255, 0)</code> — полностью прозрачный цвет.</li>
    </ul>

    <p>Также прозрачный цвет можно задать с помощью ключевого слова <code>transparent</code>.</p>

    <h3>Повторяющийся линейный градиент</h3>

    <p>Помимо обычных градиентов существуют и повторяющиеся. Их синтаксис полностью совпадает с синтаксисом обычных, только вместо <code>linear-gradient</code> пишется <code>repeating-linear-gradient</code>. Повторяющийся градиент хорош для создания полосатых фонов или фонов-орнаментов средствами CSS. Есть несколько тонкостей, которые нужно знать про повторяющиеся градиенты:</p>

    <ol>
      <li>Размер фрагмента определяется по последнему колорстопу. Чтобы повторение было видно, последний колорстоп должен быть меньше, чем размер элемента с градиентом.</li>
      <li>Если первый и последний цвета градиента различаются, то будут видны резкие границы между повторяющимися фрагментами. Чтобы от них избавиться, нужно задавать одинаковый первый и последний цвета.</li>
      <li>Колорстопы в повторяющихся градиентах обычно задают в пикселях, но можно использовать и проценты.</li>
    </ol>

    <p>Кстати, вместо повторяющихся градиентов можно использовать обычные градиенты в сочетании со свойствами <code>background-size</code> и <code>background-repeat</code>. Но повторяющиеся градиенты удобнее и требуют меньше кода.</p>

    <code class="code-block">
      .gradient-1 { <br>
        &nbsp;&nbsp;background-image: repeating-linear-gradient(black 0, green 25px, yellow 50px); <br>
      }
    </code>

    <h2>CSS Фильтры</h2>

    <p>CSS-фильтры позволяют применить визуальные эффекты к элементам страницы. Фильтры обычно применяют к изображениям, фонам или рамкам, а иногда и к другим элементам. Фильтры применяются к элементу до того, как он будет отображён, поэтому количество фильтров влияет на скорость загрузки страницы. Фильтры задаются с помощью свойства <code>filter</code>.</p>

    <p>Яркость — <code>brightness</code>. Допустимы числовые значения от <code>0</code> и выше или проценты. Со значением фильтра <code>1</code> или <code>100%</code> элемент отображается без изменений.</p>

    <code class="code-block">
      .effect { <br>
        &nbsp;&nbsp;filter: brightness(2); /* увеличивает яркость вдвое */ <br>
        &nbsp;&nbsp;filter: brightness(10%); /* снижает яркость до 10% */ <br>
        &nbsp;&nbsp;filter: brightness(150%); /* увеличивает яркость на 50% */ <br>
      }
    </code>

    <p>Контрастность — <code>contrast</code>. Как и у фильтра яркости в качестве значения можно использовать числа или проценты.</p>

    <code class="code-block">
      .effect { <br>
        &nbsp;&nbsp;filter: contrast(0.5); /* снижает контрастность наполовину */ <br>
        &nbsp;&nbsp;filter: contrast(50%); /* тоже снижает контрастность до 50% */ <br>
       }
    </code>

    <div>
      <img src="img/brightness.png" alt="Яркость и контраст" width="574" height="542">
    </div>

    <h3>Бесцветность и сепия, grayscale и sepia</h3>

    <p>Следующие два фильтра исторически относятся к фотографии: изначально фотографии были чёрно-белые или коричневатого оттенка краски сепии. С помощью фильтров бесцветности и сепии фотографиям можно придать эффект «старины». Бесцветность — <code>grayscale</code>. Допустимы числовые значения от <code>0</code> до <code>1</code> и процентные значения от <code>0%</code> до <code>100%</code>. При значениях <code>0</code> или <code>0%</code> элемент отображается без изменений.</p>

    <code class="code-block">
      .effect { <br>
        &nbsp;&nbsp;filter: grayscale(1); /* полное обесцвечивание */ <br>
        &nbsp;&nbsp;filter: grayscale(50%); /* обесцвечивание наполовину */ <br>
      }
    </code>

    <p>Сепия — <code>sepia</code>. Допустимые значения такие же, как у <code>grayscale</code>.</p>

    <code class="code-block">
      .effect { <br>
        &nbsp;&nbsp;filter: sepia(1); /* полный эффект сепии */ <br>
        &nbsp;&nbsp;filter: sepia(25%); /* эффект сепии применяется на 25% */ <br>
      }
    </code>

    <div>
      <img src="img/grayscale.png" alt="Бесцветность и сепия" width="569" height="523">
    </div>

    <h3>Инверсия и насыщенность, invert и saturate</h3>

    <p>Ещё два фильтра для цветовых эффектов — инверсия цвета и цветовая насыщенность. Как понятно из названия, при инверсии цвета меняются на противоположные, и мы получаем «негатив» картинки, а цветовая насыщенность делает краски ярче и противоположна по смыслу фильтру обесцвечивания. Инверсия цвета — <code>invert</code>. Допустимые простые числовые значения от <code>0</code> до <code>1</code> и процентные значения от <code>0%</code> до <code>100%</code>.</p>

    <code class="code-block">
      .effect { <br>
        &nbsp;&nbsp;filter: invert(1); /* полная инверсия цвета */ <br>
        &nbsp;&nbsp;filter: invert(50%); /* инверсия цвета наполовину, все цвета серые */ <br>
      }
    </code>

    <p>
      Цветовая насыщенность — <code>saturate</code>. Допустимые простые числовые значения от <code>0</code> и выше и процентные значения от <code>0%</code> и выше. При значении фильтра <code>1</code> или <code>100%</code> элемент отображается без изменений. Если установить нулевое значение, то картинка обесцветится, как при использовании фильтра <code>grayscale</code>.
    </p>

    <code class="code-block">
      .effect { <br>
        &nbsp;&nbsp;filter: saturate(2); /* цвета ярче вдвое */ <br>
        &nbsp;&nbsp;filter: saturate(50%); /* цвета вдвое бледнее */ <br>
        &nbsp;&nbsp;filter: saturate(0); /* обесцвеченная картинка */ <br>
      }
    </code>

  <div>
    <img src="img/invert.png" alt="Инверсия и насыщенность" width="581" height="532">
  </div>

  <h3>Поворот цвета, hue-rotate</h3>

  <p>Ещё один интересный цветовой фильтр — поворот цвета <code>hue-rotate</code>. Если представить все цвета в виде круга, то этим фильтром можно повернуть цвет картинки вдоль круга на определённый угол. Поворот цвета — <code>hue-rotate</code>. Значение задаётся в градусах от <code>0deg</code> до <code>360deg</code>. Допускается также использование отрицательного угла. Положительное значение будет вращать цвет по часовой стрелке, а отрицательное — против.</p>

  <div>
    <img src="img/circle.png" alt="Круг с цветами" width="222" height="230">
  </div>

  <code class="code-block">
    .effect { <br>
      &nbsp;&nbsp;filter: hue-rotate(90deg); /* поворот на 90 градусов по часовой */ <br>
      &nbsp;&nbsp;filter: hue-rotate(-90deg); /* поворот на 90 градусов обратно */ <br>
    }
  </code>

  <div>
    <img src="img/hue-rotate.png" alt="Поворот цвета" width="564" height="533">
  </div>

  <h3>Размытость и непрозрачность, blur и opacity</h3>

  <p>Не все фильтры работают с цветом. Например, фильтр размытости создаёт у фотографии эффект расфокусировки, а фильтр непрозрачности может сделать объект частично прозрачным.</p>

  <p>Фильтр <code>blur</code> задаёт размытость объекта. Его значение задаётся в пикселях от <code>0px</code> и выше.</p>

  <code class="code-block">
    .effect { <br>
      &nbsp;&nbsp;filter: blur(5px); /* размытость в 5px */ <br>
    }
  </code>

  <p>Фильтр <code>opacity</code> задаёт уровень непрозрачности объекта. Работает точно так же, как свойство <code>opacity</code>. Допустимые значения от <code>0</code> до <code>1</code> или от <code>0%</code> до <code>100%</code>.</p>

  <code class="code-block">
    .effect { <br>
      &nbsp;&nbsp;filter: opacity(0.5); /* объект наполовину непрозрачный */ <br>
      &nbsp;&nbsp;filter: opacity(0%); /* полностью прозрачный объект */ <br>
    }
  </code>

  <p>Между фильтром и свойством <code>opacity</code> всё же есть «невидимое» отличие. Некоторые браузеры используют аппаратное ускорение для отрисовки фильтров, а для свойства <code>opacity</code> ускорение не используется. Поэтому применение фильтра <code>opacity</code> может существенно улучшить производительность по сравнению с аналогичным свойством.</p>

  <div>
    <img src="img/blur.png" alt="Размытость и непрозрачность" width="554" height="532">
  </div>

  <h3>Тень, drop-shadow</h3>

  <p>С помощью фильтра <code>drop-shadow</code> можно добавить тень к объекту. Синтаксис фильтра такой же, как и у свойства <code>box-shadow</code>.</p>

  <code class="code-block">
    .effect { <br>
      &nbsp;/* <br>
      &nbsp;&nbsp;чёрная тень, смещённая на 10px по горизонтали и <br>
      &nbsp;&nbsp;на 5px по вертикали, с радиусом размытия 3px <br>
      &nbsp;*/ <br>
      &nbsp;&nbsp;filter: drop-shadow(10px 5px 3px #000000); <br> <br>

      &nbsp;/* несмещённая зелёная тень с радиусом размытия 5px */ <br>
      &nbsp;&nbsp;filter: drop-shadow(0px 0px 5px green); <br>
    }
  </code>

  <p>В отличие от <code>box-shadow</code> фильтр тени не поддерживает параметр <code>inset</code> для внутренней тени.</p>

  <div>
    <img src="img/shadow.png" alt="Тень" width="553" height="295">
  </div>

  <h3>Отличие box-shadow и drop-shadow</h3>

  <p>Фильтр тени имеет преимущества перед свойством <code>box-shadow</code>.</p>

  <p>Во-первых, при отрисовке в браузере фильтра <code>drop-shadow</code> используется аппаратное ускорение, что улучшает производительность. А дополнительного ускорения при использовании свойства <code>box-shadow</code> в браузере нет.</p>

  <p>Во-вторых, фильтр <code>drop-shadow</code> применяется к непрозрачному контуру картинок, а прозрачные области игнорируются, в то время как <code>box-shadow</code> задает прямоугольную тень по границе всего изображения.</p>

  <p>На примере полупрозрачной PNG-картинки можно оценить, как работают эти два свойства. Но стоит задать такой картинке непрозрачный фон, как поведение фильтра изменится.</p>

  <h4>Без <code>background-color: #ffffff;</code></h4>

  <div>
    <img src="img/shadow1.png" alt="Тень" width="571" height="294">
  </div>

  <h4>С <code>background-color: #ffffff;</code></h4>

  <div>
    <img src="img/shadow2.png" alt="Тень" width="588" height="274">
  </div>

  <h3>Комбинация фильтров</h3>

  <p>К одному и тому же блоку можно применить несколько фильтров одновременно. Для этого все фильтры просто перечисляются через пробел после слова <code>filter</code></p>

  <code class="code-block">
    .effect { <br>
      &nbsp;&nbsp;filter: sepia(50%) blur(5px) opacity(50%); <br>
    }
  </code>

  <p>Стоит помнить, что перечисление фильтров в разном порядке даёт разный результат. Это так, потому что каждый следующий фильтр применяется уже к изображению с эффектом.</p>

  <h3>Комбинация фильтров drop-shadow</h3>

  <p>Если применить несколько фильтров <code>drop-shadow</code> к одному блоку, то их комбинация даст интересный эффект. Так как каждый следующий фильтр в комбинации применяется к изображению с предыдущими фильтрами, то ещё одна тень у блока с тенью создаст двойную тень.</p>

  <code class="code-block">
    .effect { <br>
      &nbsp;&nbsp;/* обычная тень */ <br>
      &nbsp;&nbsp; filter: drop-shadow(0px 0px 0px black); <br><br>

      &nbsp;&nbsp;/* двойная тень */ <br>
      &nbsp;&nbsp;filter: drop-shadow(0px 0px 0px black) drop-shadow(0px 0px 0px black); <br>
    }
  </code>

  <p>Кстати, фильтр <code>drop-shadow</code> бывает полезно применять не только к изображениям, но и к обычным элементам. Тень будет, как и в случае с картинками, идти по непрозрачному контуру. В область тени включаются также псевдоэлементы блока.</p>
  </main>

  <script src="../script.js"></script>
</body>
</html>