<!DOCTYPE html>
<html lang="ru">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Flexbox</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Anonymous+Pro&family=Ubuntu:wght@400;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../../style.css">
  <link rel="stylesheet" href="style.css">
</head>

<body>

  <header>
    <label class="light">
      <input class="checkbox" type="checkbox">
      <span>Переключатель</span>
    </label>
  </header>

  <main>
    <h1>FLexbox</h1>

    <p>Флексбокс — это CSS-механизм, который позволяет контролировать размер, порядок и выравнивание элементов по
      нескольким осям, распределение свободного места между элементами и многое другое.</p>

    <div>
      <p>Чтобы включить флексбокс, нужно задать элементу свойство <code>display: flex;</code>. После этого:</p>

      <ol>
        <li>Элемент с <code>display: flex;</code> превращается во <em>«флекс-контейнер»</em>.</li>

        <li>Непосредственные потомки этого элемента превращаются во <em>«флекс-элементы»</em> и начинают распределяться
          по новым правилам.</li>
      </ol>
    </div>

    <h2>Главная и поперечная оси</h2>

    <p>Оси — одно из основных понятий во флексбоксах.</p>

    <p>В обычном потоке документа блоки и текст располагаются слева направо и сверху вниз.</p>

    <p>В привычной блочной модели направления «лево», «право», «верх» и «низ» неизменны. Но внутри флекс-контейнера эти
      понятия могут изменяться, потому что там можно изменять обычное направление потока.</p>

    <ul>
      <li><b>Главной осью</b> flex-контейнера является направление, в соответствии с которым располагаются все его
        дочерние элементы. Поток флекс-элементов «течёт» вдоль главной оси от её начала к её концу.</li>

      <li><b>Поперечной осью</b> называется направление, перпендикулярное главной оси. Вдоль этой оси работает
        «вертикальные» выравнивания.</li>
    </ul>

    <p><img src="img/flex.png" alt="Наглядное пояснения работы флекс-контейнера" width="1200" height="502"></p>

    <div>
      <p>По умолчанию главная ось направлена слева направо, но её можно разворачивать во всех направлениях с помощью
        свойства <code>flex-direction</code>, которое задаётся для флекс-контейнера. Значения свойства:</p>

      <ul>
        <li>Значение по умолчанию <code>row</code> — главная ось направлена слева направо.</li>

        <li><code>column</code> — главная ось направлена сверху вниз.</li>

        <li><code>row-reverse</code> — главная ось направлена справа налево.</li>

        <li><code>column-reverse</code> — главная ось направлена снизу вверх.</li>
      </ul>
    </div>

    <div>
      <p>Поперечная ось всегда перпендекулярна главной оси и поворачивается вместе с ней:</p>

      <ul>
        <li>Если главная ось направлена горизонтально, то поперечная ось смотрит вниз.</li>

        <li>Если главная ось направлена вертикально, то поперечная ось смотрит направо.</li>
      </ul>
    </div>

    <p>Таким образом, поперечная ось никогда не смотрит вверх или влево, и свойства для поворота поперечной оси нет.</p>

    <h2>Распределение флекс-элементов</h2>

    <div>
      <p><i>Выравнивание по главной оси</i></p>

      <p>CSS-свойство <code>justify-content</code> определяет то, как будут выровнены элемент вдоль главной оси.
        Доступные значения <b>justify-content</b>:</p>

      <ul>
        <li>Значение по умолчанию <code>flex-start</code> — элементы располагаются у начала главной оси.</li>

        <li><code>flex-end</code> — элементы располагаются в конце главной оси.</li>

        <li><code>center</code> — элементы располагаются по центру главной оси.</li>

        <li><code>space-between</code> — элементы располагаются так, что расстояние между соседними одинаковые, а между
          элементами и краями флекс-контейнера отступов нет.</li>

        <li><code>space-around</code> — элементы располагаются так, что расстояние между соседними одинаковые, а между
          элементами и краями флекс-контейнера есть отступ, равный половине расстояния между соседними элементами.</li>

        <li><code>space-evenly</code> — расстояние между соседними элементами и краями флекс-контейнера одинаковые.</li>
      </ul>
    </div>

    <div>
      <p><i>Вырванивание по поперечной оси</i></p>

      <p>CSS-свойство <code>align-items</code> определяет то, как будут выровнены элементы вдоль поперечной оси. Доступные значения <code>align-items</code>: </p>

      <ul>
        <li>Значение по умолчанию <code>stretch</code> — элементы растягиваются на всю «высоту» флекс-контейнера.</li>

        <li><code>flex-start</code> — элементы располагаются у начала поперечной оси.</li>

        <li><code>flex-end</code> — элементы располагаются в конце поперечной оси.</li>

        <li><code>center</code> — элементы располагаются по центру поперечной оси.</li>

        <li><code>baseline</code> — элементы выравниваются по базовой линии текста внутри них.</li>
      </ul>
    </div>

    <p>Распределение элементов по главной оси задаётся для всего флекс-контейнера и на все флекс-элементы действует одинаково, задать какому-то элементу отличное от других распределение по главной оси нельзя.</p>

    <p>Поперечное выравнивание можно задать каждому элементу отдельно. Для этого используется свойство <code>align-self</code>, которое задаётся для самих флекс-элементов, а не для флекс-контейнера. У свойства <code>align-self</code> те же самые значения, что и у <code>align-items</code>.</p>

    <h2>Перенос флекс-элементов</h2>

    <div>
      <p>Если флекс-элементов в контейнере станет больше, чем может уместиться в один ряд, то:</p>

      <ul>
        <li>Они будут сжиматься до минимально возможной ширины.</li>

        <li>Даже если им задать ширину, механизм флексбокса может ее уменьшить.</li>

        <li>Если они перестанут помещаться в контейнер и после уменьшения, то выйдут за его пределы, но продолжат распологаться в один ряд.</li>
      </ul>
    </div>

    <div>
      <p>Чтобы этого не происходило, нужно воспользоваться свойством флекс-контейнера <code>flex-wrap</code>. У него есть два значения:</p>

      <ul>
        <li>Значение по умолчанию <code>nowrap</code> — перенос флекс-элементов на новую строку запрещен.</li>

        <li><code>wrap</code> — разрешает перенос флекс-элементов на новую строку. Ряды элементов располагаются вдоль поперечной оси, первый ряд — в начале поперечной оси, последний — в конце.</li>

        <li><code>wrap-reverse</code> — также разрешает перенос флекс-элементов на новую строку. Ряды элементов располагатся в обратном порядке: первый — в конце поперечной оси, последний — в начале.</li>
      </ul>
    </div>

    <h2>Выравнивание строк флекс-контейнера</h2>

    <div>
      <p>Свойство <code>align-content</code> управляет выравниванием рядов флекс-элементов вдоль поперечной оси. У него и свойства <code>justify-content</code> очень похожие значения:</p>

      <ul>
        <li>Значение по умолчанию <code>stretch</code> — растягивает ряды флекс-элементов, при этом оставшееся свободное место между ними делится поровну. Отображение строк при этом зависит от значения <code>align-items</code>: <br><br>

          <ol>
            <li>Если у <code>align-items</code> задано значение <code>stretch</code>, то элементы в строках растягиваются на всю высоту своей строки.</li>

            <li>Если значение отлично от <code>stretch</code>, то элементы в строках ужимаются под своё содержимое и выравниваются в строках в зависимости от значения <code>align-items</code>.</li>
          </ol>
        </li>

        <li>
          <code>flex-start</code> — располагает ряды флекс-элементов в начале поперечной оси.
        </li>

        <li><code>flex-end</code> — располагает ряды флекс-элементов в конце поперечной оси.</li>

        <li><code>center</code> — располагает ряды флекс-элементов в середине поперечной оси так, что отступов между соседними рядами нет, а расстояние между первым рядом и краем флекс-контейнера равно расстоянию между последним рядом и другим краем.</li>

        <li><code>space-between</code> — равномерно распределяет ряды флекс-элементов вдоль поперечной оси, расстояние между соседними рядами одинаковые, отступов у краёв нет.</li>

        <li><code>space-around</code> — равномерно распределяет ряды флекс-элементов вдоль поперечной оси, расстояние между соседними рядами одинаковые, отступы у краёв равны половине расстояния между соседними рядами.</li>

        <li><code>space-evenly</code> — равномерно распределяет ряды вдоль поперечной оси, расстояние между соседними рядами и у краёв одинаковые.</li>
      </ul>

      <p>Свойство <code>align-content</code> «перекрывает» заданное значение <code>align-items</code>, которое управляет выравниванием флекс-элементов вдоль поперечной оси. Это происходит в случае, когда есть только один ряд флекс-элементов, и когда рядов несколько.</p>
    </div>

    <div>
      <p>Ранее в спецификации было описано другое поведение:</p>

      <ul>
        <li>Если есть только один ряд флекс-элементов, то работает <code>align-items</code>.</li>

        <li>Если есть несколько рядов, то работает <code>align-content</code>.</li>
      </ul>

      <p>В начале 2019 года поведение было актуализировано согласно спецификации во всех современных браузерах, теперь его можно встретить только в старых браузерах.</p>
    </div>

    <h2>Порядковый номер флекс-элемента</h2>

    <p>Порядок следования флекс-элементов в потоке можно изменять с помощью свойства <code>order</code>, порядкового номера флекс-элемента, не меняя при этом HTML-код.</p>

    <p>По умолчанию порядковый номер флекс-элементов равен <code>0</code>, а сортировка элементов производится по возрастанию номера. Порядковый номер задаётся целым числом, положительным или отрицательным.</p>

    <h2>Применение флексбоксов</h2>

    <h3>Идеальное выравнивание</h3>

    <p>С помощью флексбокса можно отцентрировать элемент по вертикали и горизонтали так, чтобы центровка сохранялась при изменении размеров элемента или контейнера.</p>

    <p>Для этого нужно задать контейнеру раскладку флексбокса, а дочернему флекс-элементу <code>margin: auto</code>. В этом случае флекс-элемент уменьшит свой размер под содержимое и отцентрируется по вертикали и горизонтали.</p>

    <h3>«Гибкое» меню</h3>

    <h3>Сортировка элементов на CSS</h3>

    <p>Используя одновременно флексбокс и селектор по выделению чекбокса <code>:ckecked ~</code>, можно с помощью селектора управлять порядком флекс-элементов, изменяя направление главной оси с помощью <code>flex-direction</code>.</p>

    <p>Лучше всего эффект работает, когда направление главной оси меняется с «сверху вниз» на «снизу вверх». При этом флекс-контейнер должен находиться в разметке на одном уровне с чекбоксом.</p>

    <h3>Блоки одинаковой высоты</h3>

    <h2>Особенности свойства margin</h2>

    <ul>
      <li>внешние отступы не схлопываются, ни по горизонтали, ни по вертикали;</li>
      <li>внешние отступы не выпадают, ни из флекс контейнера;</li>
      <li>значение <code>auto</code> — самое влиятельное значение css-свойсто внутри флекс-контейнера. (отменяет свойство align-items, align-self, justify-content)</li>
    </ul>

    <h2>Базовый размер флекс-элемента, flex-basis</h2>

    <p>Ширина и высота тоже не умеют реагировать на поворот главной оси. Поэтому ввели понятия <i>главный размер</i> или <i>main size</i> и <i>поперечный размер</i> или <i>cross size</i>.</p>

    <p>Если главная ось направлена горизонтально, то главный размер — это ширина, свойство <code>width</code>, а поперечный размер — это высота, свойство <code>height</code>. Если главная ось направлена вертикально, то всё наоборот.</p>

    <p>А хотелось бы иметь «умное» свойство для задания размера флекс-элементов, которое знает про главную ось и «поворачивается» вместе с ней.</p>

    <p>И такое свойство есть — это <code>flex-basis</code>. Оно задаёт базовый размер флекс-элемента или размер вдоль главной оси.</p>

    <p>Если <code>flex-basis</code> не задан или его значение равно <code>auto</code>, то базовый размер берётся из <code>width</code> или <code>height</code>.</p>

    <p>Свойство <code>flex-basis</code> «сильнее» свойств <code>width</code> и <code>height</code>, и если у флекс-элемента заданы все три свойства, то <code>flex-basis</code> переопределит либо ширину, либо высоту в зависимости от направления главной оси.</p>

    <h2>Коэффициент растягивания элементов, flex-grow</h2>

    <h2>Пропорциональное растягивание элементов</h2>

    <p>Если сразу у нескольких флекс-элементов значение <code>flex-grow</code> больше нуля, то они будут делить свободное место между собой.</p>

    <h2>Расчёт итогового размера с flex-grow</h2>

    <ol>
      <li>Рассчитываем свободное место во флекс-контейнере: <br>
        <code class="code-block">Свободное место = Ширина контейнера - Сумма базовых размеров элементов</code>
      </li>

      <li>Считаем размер минимальной доли свободного места: <br>
        <code class="code-block">Доля свободного места = Свободное место / Сумма flex-grow всех элементов</code>
      </li>

      <li>Базовый размер каждого флекс-элемента увеличиваем на размер минимальной доли свободного места, умноженной на значение <code>flex-grow</code> этого элемента: <br>
        <code class="code-block">Итоговый размер = Базовый размер + (Доля свободного места * flex-grow)</code>
      </li>
    </ol>

    <h3>ПРИМЕР:</h3>

    <p><img src="img/flex-grow.png" alt="Пример" width="516" height="334"></p>

    <code class="code-block">
      Свободное место = 300px - (50px * 2) = 200px <br>
      Доля свободного места = 200px / (1 + 3) = 50px <br>
      Итоговый размер зелёного енота = 50px + (50px * 1) = 100px <br>
      Итоговый размер коричневого енота = 50px + (50px * 3) = 200px
    </code>

    <p>Но если задать флекс-элементам нулевой базовый размер, свободное место будет занимать всю ширину флекс-контейнера, и коэффициенты жадности будут другими. <br>

      <div class="border">Использовать <code>flex-basis: 0</code> и <code>flex-grow</code> для точного управления относительными размерами не стоит. Лучше использовать базовый размер в процентах.</div> <br>

      <i>Тонкость</i>. На размер оставшегося свободного места влияет не только <code>flex-basis</code>, но и рамки, и отступы. Если <code>flex-basis</code> явно задано нулевое значение, то <code>min-width</code> на размер свободного места влиять не будет, так как ограничения размеров к флекс-элементам применяются уже после перераспределения свободного места.</p>

    <h2>Коэффициент сжатия элементов, flex-shrink</h2>

    <p>Если сумма базовых размеров флекс-элементов больше, чем размер флекс-контейнера, то возникает отрицательное пространство. <br>

      Механизм перераспределения работает не только для свободного места, но и для отрицательного пространства. Флекс-элементы умеют распределять отрицательное пространство между собой и сжиматься. <br>
      Флекс-элементы стараются быть максимально «гибкими» и не выпадать из своего контейнера, поэтому у <code>flex-shrink</code> значение по умолчанию равно <code>1</code>. Но если задавать нулевые значения для коэффициента сжатия, то выпадения элементов добиться можно.</p>

    <p>Свойство <code>flex-shrink</code> очень похоже на свойство <code>flex-grow</code>. Оно задаёт пропорции, в которых флекс-элементы «впитывают» отрицательное пространство. <br>

      Чем больше значение коэффициента сжатия у элемента, тем больше отрицательного пространства он «впитает» и тем сильнее сожмётся. <br>

      Когда базовые размеры флекс-элементов одинаковы, пропорции сжатия элементов считаются так же, как пропорции увеличения. </p>

    <h2>Расчёт итогового размера с flex-shrink</h2>

    <ol>
      <li>Рассчитываем отрицательное пространство (ОП) во флекс-контейнере: <br>
        <code class="code-block">ОП = Ширина контейнера - Сумма базовых размеров элементов</code>
      </li>

      <li>Находим сумму произведений базовых размеров (СПБР) элементов на их коэффициенты сжатия: <br>
        <code class="code-block">СПБР = (Базовый размер<sub>1</sub> * flex-shrink <sub>1</sub>) + (Базовый размер<sub>2</sub> * flex-shrink<sub>2</sub>) + … + (Базовый размер<sub>n</sub> * flex-shrink<sub>n</sub>)</code>
      </li>

      <li>Для каждого элемента считаем «нормированный коэффициент сжатия» (НКС), для чего произведение базового размера элемента на его коэффициент сжатия делим на СПБР: <br>
        <code class="code-block">НКС = (Базовый размер * flex-shrink) / СПБР</code>
      </li>

      <li>Базовый размер элемента уменьшаем на часть ОП пропорциональную НКС элемента. ОП для расчёта берём по модулю, то есть отбрасывая минус: <br>
        <code class="code-block">Итоговый размер = Базовый размер - (НКС * ОП)</code>
      </li>
    </ol>

    <p>Получается, что доля отрицательного пространства, которую «впитает» элемент, зависит от двух факторов:</p>

    <ul>
      <li>соотношения коэффициента сжатия элемента с коэффициентами других элементов;</li>
      <li>соотношения базового размера элемента с базовыми размерами других элементов.</li>
    </ul>

    <h2>flex-shrink и min-width</h2>

    <p><img src="img/flex-shrink.png" alt="flex-shrink" width="404" height="245"></p>

    <code class="code-block">
      Отрицательное пространство = 200px - 100px - 300px = -200px <br>

      Сумма произведений размеров на коэффициенты = (1 * 100px) + (1 * 300px) = 400px <br>

      Нормированный коэффициент 1 элемента = (1 * 100px) / 400px = 0.25 <br>
      Нормированный коэффициент 2 элемента = (1 * 300px) / 400px = 0.75 <br>

      Итоговый размер 1 элемента = 100px - (200px * 0.25) = 50px <br>
      Итоговый размер 2 элемента = 300px - (200px * 0.75) = 150px
    </code>

    <p>Есть несколько тонкостей, касающихся сжатия флекс-элементов:</p>

    <ul>
      <li>элементы сжимаются в пределах своих базовых размеров, внутренние отступы и рамки не сжимаются;</li>

      <li>«ограничительные» свойства, такие как min-width, применяются к элементам после этапа перераспределения свободного места или отрицательного пространства.</li>
    </ul>

    <h2>Сокращённое свойство flex</h2>

    <p>Значения: <code>flex-grow</code>, <code>flex-shrink</code>, <code>flex-basis</code>. Также есть особые значения: <code>inital</code>, <code>auto</code>, <code>none</code>.</p>

    <code class="code-block">
      flex: initial; -> flex: 0 1 auto; <br>
      flex: auto;  -> flex: 1 1 auto; <br>
      flex: none;  -> flex: 0 0 auto; <br>
      flex: 1 0;   -> flex: 1 0 0%; <br>
      flex: 1;     -> flex: 1 1 0%;
    </code>
  </main>

  <script src="../../script.js"></script>
</body>

</html>